<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hallways — v.Testing (Made byGreat Jake)</title>
  <style>
    html,body{height:100%;margin:0;background:#060607;overflow:hidden;font-family:Inter,Segoe UI,Roboto,Arial;color:#efe9d6}
    canvas{display:block;width:100%;height:100%}
    .overlay{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none}
    .crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:18px;height:18px;pointer-events:none}
    .crosshair:after{content:"";display:block;width:3px;height:3px;background:#ffd54f;border-radius:50%;box-shadow:0 0 18px #ffb74d}
    .hud{position:fixed;left:12px;top:12px;background:rgba(0,0,0,.55);padding:10px 14px;border-radius:10px;font-size:14px;pointer-events:auto}
    .hint{position:fixed;left:50%;transform:translateX(-50%);bottom:8%;background:rgba(0,0,0,.6);padding:10px 14px;border-radius:12px;font-weight:600;pointer-events:auto}
    .barWrap{position:fixed;top:14px;left:50%;transform:translateX(-50%);width:320px;background:#111;border-radius:10px;overflow:hidden;display:none;pointer-events:none}
    .bar{height:14px;background:#ff3b3b;width:100%}
    .centerMsg{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;padding:26px;border-radius:14px;display:none;text-align:center}
    button{border:0;border-radius:8px;padding:8px 14px;background:#ffd54f;font-weight:700;cursor:pointer}
    .screen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#050405,#0b0710);z-index:40}
    .menuCard{background:rgba(0,0,0,.6);padding:28px;border-radius:12px;text-align:center;color:#fff}
    .slider{width:220px}
  </style>
</head>
<body>
  <div class="overlay">
    <div class="crosshair"></div>
    <div class="hud" id="hud">
      <div id="status">Status: Home</div>
      <div style="margin-top:6px">
        <button id="settingsBtn">Settings (Esc)</button>
      </div>
    </div>
    <div class="barWrap" id="bossBar"><div class="bar" id="bossHP"></div></div>
    <div class="hint" id="hint">WASD move · SPACE jump · Look at gun + E</div>
  </div>

  <div class="centerMsg" id="endScreen">
    <h2 id="endTitle"></h2>
    <p id="endText"></p>
    <button onclick="location.reload()">Play Again</button>
  </div>

  <canvas id="c"></canvas>

  <div class="screen" id="homeScreen">
    <div class="menuCard">
      <h1 style="margin:0 0 8px 0">Hallways — v.Testing (Made byGreat Jake)</h1>
      <p style="opacity:.8">this is still in testing </p>
      <div style="margin-top:14px"><button id="playBtn">Play</button></div>
      <audio id="bgMusic" loop src="https://cdn.jsdelivr.net/gh/jake-demo-assets/creepy-loop.mp3"></audio>
    </div>
  </div>

  <div class="screen" id="settingsScreen" style="display:none;align-items:flex-start;padding-top:80px;">
    <div class="menuCard">
      <h3 style="margin-top:0">Settings</h3>
      <div style="margin:10px 0">Brightness: <span id="brightVal">100</span>%</div>
      <input id="brightness" class="slider" type="range" min="30" max="180" value="100" />
      <div style="margin-top:12px"><button id="backHome">Back to Home</button></div>
      <div style="margin-top:8px"><button id="closeSettings">Close</button></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x060607, 0.02);
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);

    scene.add(new THREE.AmbientLight(0x404040, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.3);
    dirLight.position.set(3, 10, 6);
    scene.add(dirLight);

    const player = { pos:new THREE.Vector3(0,1.6,2), vel:0, grounded:true };
    let yaw=0,pitch=0;
    const keys={};
    addEventListener('keydown', e=>{ keys[e.code]=true;if(e.code==='Escape') toggleSettings(); });
    addEventListener('keyup', e=>{ keys[e.code]=false; });

    // UI and screens
    const homeScreen = document.getElementById('homeScreen');
    const settingsScreen = document.getElementById('settingsScreen');
    const bgMusic = document.getElementById('bgMusic');
    let started=false;
    let startYaw=0;
    let startPos = player.pos.clone();
    document.getElementById('playBtn').onclick=()=>{homeScreen.style.display='none'; bgMusic.play().catch(()=>{}); startGame();};
    document.getElementById('settingsBtn').onclick=toggleSettings;
    document.getElementById('closeSettings').onclick=toggleSettings;
    document.getElementById('backHome').onclick=()=>location.reload();
    const brightness = document.getElementById('brightness'); const brightVal = document.getElementById('brightVal');
    brightness.oninput=()=>{brightVal.textContent=brightness.value; canvas.style.filter=`brightness(${brightness.value}%)`;};
    function toggleSettings(){settingsScreen.style.display=settingsScreen.style.display==='flex'?'none':'flex';}

    // Hallway
    const hall = new THREE.Group(); scene.add(hall);
    const floorMat=new THREE.MeshStandardMaterial({color:0x2a1c12});
    const wallMat=new THREE.MeshStandardMaterial({color:0x1b120b});
    const SEG_LEN=12, SEG_COUNT=14, segments=[];
    function makeSegment(z){
      const g=new THREE.Group();
      const floor=new THREE.Mesh(new THREE.BoxGeometry(6,0.2,SEG_LEN), floorMat); floor.receiveShadow=true; g.add(floor);
      const wallL=new THREE.Mesh(new THREE.BoxGeometry(0.5,4,SEG_LEN), wallMat); wallL.position.set(-3,2,0); g.add(wallL);
      const wallR=wallL.clone(); wallR.position.x=3; g.add(wallR);
      const bulb=new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8), new THREE.MeshStandardMaterial({emissive:0xffe8b0,emissiveIntensity:1.2,color:0x202020})); bulb.position.set(0,3.6,0); g.add(bulb);
      const pl=new THREE.PointLight(0xfff1b8,0.9,18); pl.position.set(0,3.6,0); g.add(pl);
      g.position.z=z; hall.add(g);
      return g;
    }
    for(let i=0;i<SEG_COUNT;i++) segments.push(makeSegment(-i*SEG_LEN));
    function updateHall(){ const last=segments[segments.length-1]; if(player.pos.z<last.position.z+SEG_LEN*1.5){ const seg=segments.shift(); seg.position.z=segments[segments.length-1].position.z-SEG_LEN; segments.push(seg); } }

    // Gun
    const gun=new THREE.Mesh(new THREE.BoxGeometry(0.8,0.2,0.3), new THREE.MeshStandardMaterial({color:0x444444})); gun.position.set(0,1,-18); scene.add(gun); let hasGun=false;

    // Colors: body/head pink, limbs darker pink
    const BODY_PINK = 0xff84b3; // pale pink
    const LIMB_DARK_PINK = 0xb30059; // darker pink

    // Monster (body + limbs)
    const monster = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ color: BODY_PINK, roughness: 0.95, metalness: 0.05, emissive: 0x0a0012, emissiveIntensity: 0.02 });
    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.9, 1.0, 6, 10), bodyMat);
    body.castShadow = true; body.receiveShadow = true; body.position.set(0,1.2,0); monster.add(body);

    // create a smiley face texture on a canvas and return a THREE.Texture
    function createFaceTexture(){
      const size = 512;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      // background transparent
      ctx.clearRect(0,0,size,size);
      // face circle (slightly lighter pink so it reads on the pink head)
      ctx.fillStyle = '#ffd6e8'; // pale blush circle
      ctx.beginPath();
      ctx.arc(size/2, size/2, size*0.42, 0, Math.PI*2);
      ctx.fill();
      // eyes (black)
      ctx.fillStyle = '#000000';
      const eyeR = size * 0.12;
      ctx.beginPath();
      ctx.arc(size*0.38, size*0.44, eyeR, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(size*0.62, size*0.44, eyeR, 0, Math.PI*2);
      ctx.fill();
      // smile (thick arc)
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = size*0.06;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.arc(size/2, size/2 + size*0.06, size*0.22, 0.15*Math.PI, 0.85*Math.PI);
      ctx.stroke();
      // subtle blush dots
      ctx.fillStyle = 'rgba(255, 120, 170, 0.12)';
      ctx.beginPath();
      ctx.arc(size*0.28, size*0.54, size*0.05, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(size*0.72, size*0.54, size*0.05, 0, Math.PI*2);
      ctx.fill();

      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      return tex;
    }

    // Head with smiley texture
    const headTex = createFaceTexture();
    const headMat = new THREE.MeshStandardMaterial({ map: headTex, color: 0xffffff, roughness: 0.9 });
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.45, 24, 20), headMat);
    head.position.set(0,2.1,0.12);
    monster.add(head);

    // Glow (soft halo)
    const glow = new THREE.Mesh(new THREE.SphereGeometry(1.8, 16, 12), new THREE.MeshBasicMaterial({ color: 0xffd27a, transparent: true, opacity: 0.04 }));
    glow.position.set(0, 1.6, 0); monster.add(glow);

    // Limbs: arms and legs (now use darker pink material)
    const limbMat = new THREE.MeshStandardMaterial({ color: LIMB_DARK_PINK, roughness: 0.9, metalness:0.03 });
    const upperArmGeom = new THREE.CylinderGeometry(0.12,0.12,0.7,10);
    const lowerArmGeom = new THREE.CylinderGeometry(0.1,0.1,0.6,10);
    const thighGeom = new THREE.CylinderGeometry(0.16,0.16,0.8,12);
    const shinGeom = new THREE.CylinderGeometry(0.14,0.14,0.8,12);

    // left upper arm
    const leftUpperArm = new THREE.Mesh(upperArmGeom, limbMat);
    leftUpperArm.geometry.translate(0, -0.35, 0); // pivot at shoulder
    leftUpperArm.position.set(-0.95, 1.95, 0.18);
    leftUpperArm.rotation.z = 0.2;
    monster.add(leftUpperArm);

    const leftLowerArm = new THREE.Mesh(lowerArmGeom, limbMat);
    leftLowerArm.geometry.translate(0, -0.3, 0); // pivot at elbow
    leftLowerArm.position.set(-0.95, 1.55, 0.18);
    monster.add(leftLowerArm);

    const rightUpperArm = leftUpperArm.clone();
    rightUpperArm.position.set(0.95, 1.95, 0.18);
    rightUpperArm.rotation.z = -0.2;
    monster.add(rightUpperArm);

    const rightLowerArm = leftLowerArm.clone();
    rightLowerArm.position.set(0.95, 1.55, 0.18);
    monster.add(rightLowerArm);

    // legs
    const leftThigh = new THREE.Mesh(thighGeom, limbMat);
    leftThigh.geometry.translate(0, -0.4, 0);
    leftThigh.position.set(-0.35, 0.75, 0);
    leftThigh.rotation.x = 0.02;
    monster.add(leftThigh);

    const leftShin = new THREE.Mesh(shinGeom, limbMat);
    leftShin.geometry.translate(0, -0.4, 0);
    leftShin.position.set(-0.35, 0.1, 0);
    leftShin.rotation.x = 0.02;
    monster.add(leftShin);

    const rightThigh = leftThigh.clone();
    rightThigh.position.set(0.35, 0.75, 0);
    monster.add(rightThigh);

    const rightShin = leftShin.clone();
    rightShin.position.set(0.35, 0.1, 0);
    monster.add(rightShin);

    // hands/feet caps (dark pink)
    const footGeom = new THREE.SphereGeometry(0.14, 12, 10);
    const leftFoot = new THREE.Mesh(footGeom, limbMat); leftFoot.position.set(-0.35, -0.4, 0); monster.add(leftFoot);
    const rightFoot = new THREE.Mesh(footGeom, limbMat); rightFoot.position.set(0.35, -0.4, 0); monster.add(rightFoot);
    const leftHand = new THREE.Mesh(footGeom, limbMat); leftHand.position.set(-0.95, 1.15, 0.3); monster.add(leftHand);
    const rightHand = new THREE.Mesh(footGeom, limbMat); rightHand.position.set(0.95, 1.15, 0.3); monster.add(rightHand);

    monster.visible = false; scene.add(monster);
    let monsterHP = 100;

    // monster userData defaults for animation
    monster.userData.state = 'idle'; // idle, windup, leap, landed
    monster.userData.vy = 0;
    monster.userData.hVel = new THREE.Vector3();
    monster.userData.animTimer = 0;

    // particles (dust)
    const particles = []; // {mesh, vel:Vector3, life, initLife}
    function spawnLandingParticles(pos, normal, count=26){
      for(let i=0;i<count;i++){
        const g = new THREE.SphereGeometry(0.055 * (0.6 + Math.random()*0.9), 6, 6);
        const m = new THREE.MeshBasicMaterial({color: 0xffd6e8, transparent:true, opacity:1});
        const p = new THREE.Mesh(g, m);
        p.position.copy(pos);
        p.position.y += 0.12 + Math.random()*0.12;
        const angle = Math.random() * Math.PI * 2;
        const speed = 1.8 + Math.random() * 2.6;
        p.userData = {
          vel: new THREE.Vector3(Math.cos(angle) * speed * (0.6+Math.random()*0.8), 1.0 + Math.random()*1.4, Math.sin(angle) * speed * (0.6+Math.random()*0.8)),
          life: 0.6 + Math.random()*0.9
        };
        scene.add(p);
        particles.push(p);
      }
    }

    // bullets
    const bullets=[]; function spawnBullet(origin,dir){const b=new THREE.Mesh(new THREE.SphereGeometry(0.06,8,8), new THREE.MeshStandardMaterial({emissive:0xffe0a4,emissiveIntensity:2,color:0x222222})); b.position.copy(origin); scene.add(b); bullets.push({mesh:b,vel:dir.clone().multiplyScalar(60),life:2});}

    // state
    let chasing=false, cutsceneActive=false, cutsceneTimer=0, gameOver=false;
    let cutsceneStage = 0;
    let cameraTurnTarget = 0;
    let cameraShake = {time:0, intensity:0, duration:0};

    // Create a wall behind the player at start for collision
    const startWall = new THREE.Mesh(
      new THREE.BoxGeometry(4, 3, 0.2),
      new THREE.MeshStandardMaterial({ color: 0x555555 })
    );
    startWall.position.set(0, 1.5, 4); // Behind the start position
    scene.add(startWall);
    const collidableObjects = [startWall]; // Array for collision detection

    function startCutscene(){
      if(cutsceneActive) return;
      cutsceneActive=true;
      cutsceneTimer=0;
      cutsceneStage=0;
      monster.visible=false;
      monsterHP=100;
      cameraTurnTarget = startYaw;
      monsterSpeak('Who walks the hallway?');
      document.getElementById('bossBar').style.display='block';
      document.getElementById('bossHP').style.width = monsterHP + '%';
      monster.userData.state = 'idle';
      monster.userData.vy = 0;
      monster.userData.hVel.set(0,0,0);
      // neutral limb targets
      setLimbTargets({windUp:false});
    }

    function monsterSpeak(text){ document.getElementById('status').textContent=text; if('speechSynthesis' in window && text){ const u=new SpeechSynthesisUtterance(text); u.pitch=0.45; u.rate=0.95; speechSynthesis.cancel(); speechSynthesis.speak(u);}}

    function win(){if(gameOver) return; gameOver=true; document.getElementById('endTitle').textContent='You killed it'; document.getElementById('endText').textContent='You survived — Great Jake'; document.getElementById('endScreen').style.display='block';}
    function lose(){if(gameOver) return; gameOver=true; document.getElementById('endTitle').textContent='You were caught'; document.getElementById('endText').textContent='The hallway is silent again'; document.getElementById('endScreen').style.display='block';}

    // pointer & drag look
    let pointerLocked=false; let dragging=false; let lastX=0,lastY=0;
    canvas.addEventListener('click',()=>{ try{ canvas.requestPointerLock(); }catch(e){} });
    document.addEventListener('pointerlockchange',()=>{ pointerLocked = document.pointerLockElement === canvas; });
    window.addEventListener('mousedown',(e)=>{ if(!pointerLocked){ dragging=true; lastX=e.clientX; lastY=e.clientY; } });
    window.addEventListener('mouseup',()=>{ dragging=false; });
    window.addEventListener('mousemove',(e)=>{
      const sens=0.0028;
      if(pointerLocked){ yaw -= e.movementX * sens; pitch -= e.movementY * sens; }
      else if(dragging){ yaw -= (e.clientX-lastX) * sens; pitch -= (e.clientY-lastY) * sens; lastX=e.clientX; lastY=e.clientY; }
      pitch = Math.max(-1.3,Math.min(1.3,pitch));
    });

    // shooting
    addEventListener('click',(ev)=>{ if(!hasGun || cutsceneActive || gameOver) return; const origin = camera.position.clone(); const dir=new THREE.Vector3(); camera.getWorldDirection(dir); spawnBullet(origin.add(dir.clone().multiplyScalar(0.8)), dir); });

    // limb animation targets (we'll lerp toward these)
    const limbTargets = {
      leftUpperArm: new THREE.Euler().copy(leftUpperArm.rotation),
      leftLowerArm: new THREE.Euler().copy(leftLowerArm.rotation),
      rightUpperArm: new THREE.Euler().copy(rightUpperArm.rotation),
      rightLowerArm: new THREE.Euler().copy(rightLowerArm.rotation),
      leftThigh: new THREE.Euler().copy(leftThigh.rotation),
      leftShin: new THREE.Euler().copy(leftShin.rotation),
      rightThigh: new THREE.Euler().copy(rightThigh.rotation),
      rightShin: new THREE.Euler().copy(rightShin.rotation),
    };

    function setLimbTargets({windUp=false, leap=false, land=false}){
      if(windUp){
        limbTargets.leftUpperArm.set(-0.1, 0, 0.9);
        limbTargets.leftLowerArm.set(-0.8, 0, 0.2);
        limbTargets.rightUpperArm.set(-0.1, 0, -0.9);
        limbTargets.rightLowerArm.set(-0.8, 0, -0.2);
        limbTargets.leftThigh.set(0.4,0,0.08);
        limbTargets.leftShin.set(0.2,0,0.02);
        limbTargets.rightThigh.set(0.4,0, -0.08);
        limbTargets.rightShin.set(0.2,0,0.02);
      } else if(leap){
        limbTargets.leftUpperArm.set(-0.6, 0, 0.35);
        limbTargets.leftLowerArm.set(-0.6, 0, 0.1);
        limbTargets.rightUpperArm.set(-0.6, 0, -0.35);
        limbTargets.rightLowerArm.set(-0.6, 0, -0.1);
        limbTargets.leftThigh.set(0.9,0,0.02);
        limbTargets.leftShin.set(1.0,0,0.02);
        limbTargets.rightThigh.set(0.9,0,-0.02);
        limbTargets.rightShin.set(1.0,0,0.02);
      } else if(land){
        limbTargets.leftUpperArm.set(1.3, 0, -1.9);
        limbTargets.leftLowerArm.set(-0.6, 0, -0.2);
        limbTargets.rightUpperArm.set(-0.8, 0, 0.6);
        limbTargets.rightLowerArm.set(-0.9, 0, 0.2);
        limbTargets.leftThigh.set(1.35,0,-0.06);
        limbTargets.leftShin.set(1.3,0,0.04);
        limbTargets.rightThigh.set(1.25,0,0.08);
        limbTargets.rightShin.set(1.15,0,0.02);
      } else {
        limbTargets.leftUpperArm.set(0.2, 0, 0.2);
        limbTargets.leftLowerArm.set(0, 0, 0);
        limbTargets.rightUpperArm.set(-0.2, 0, -0.2);
        limbTargets.rightLowerArm.set(0, 0, 0);
        limbTargets.leftThigh.set(0.02,0,0);
        limbTargets.leftShin.set(0.02,0,0);
        limbTargets.rightThigh.set(0.02,0,0);
        limbTargets.rightShin.set(0.02,0,0);
      }
    }

    setLimbTargets({windUp:false});

    function lerpEuler(current, target, t){
      current.x += (target.x - current.x) * t;
      current.y += (target.y - current.y) * t;
      current.z += (target.z - current.z) * t;
    }

    // Main loop
    let lastTime=null;
    function shortestAngleDiff(a, b){
      let diff = (b - a + Math.PI) % (Math.PI*2) - Math.PI;
      return diff;
    }

    function loop(ts){ if(lastTime===null) lastTime=ts; let dt=(ts-lastTime)/1000; if(dt>0.06) dt=0.06; lastTime=ts;

      // movement (disabled during cutscene)
      if(!cutsceneActive&&!gameOver){
        const speed=6;
        const inputZ=(keys['KeyW']?1:0)-(keys['KeyS']?1:0);
        const inputX=(keys['KeyD']?1:0)-(keys['KeyA']?1:0);
        if(keys['Space']&&player.grounded){player.vel=6;player.grounded=false;}
        if(inputX!==0||inputZ!==0){
          const forward=new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
          const right=new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
          const move=new THREE.Vector3();
          move.addScaledVector(forward,inputZ); move.addScaledVector(right,inputX);
          if(move.lengthSq()>0){ move.normalize().multiplyScalar(speed*dt); player.pos.add(move); }
        }
      }

      // update camera BEFORE raycasts so direction is accurate
      camera.position.copy(player.pos); camera.rotation.order='YXZ'; camera.rotation.y=yaw; camera.rotation.x=pitch;

      // camera shake effect application
      if(cameraShake.time > 0){
        cameraShake.time -= dt;
        const s = cameraShake.intensity * (cameraShake.time / cameraShake.duration);
        camera.position.x += (Math.random()*2-1) * s;
        camera.position.y += (Math.random()*2-1) * s * 0.5;
        camera.position.z += (Math.random()*2-1) * s * 0.5;
      }

      // gravity for player
      player.vel-=dt*12; player.pos.y+=player.vel*dt; if(player.pos.y<=1.6){player.pos.y=1.6;player.vel=0;player.grounded=true;}

      // check collisions
      for(const obj of collidableObjects){
        const distX = Math.abs(player.pos.x - obj.position.x);
        const distY = Math.abs(player.pos.y - obj.position.y);
        const distZ = Math.abs(player.pos.z - obj.position.z);
        const sizeX = (obj.geometry.parameters.width || 1) / 2;
        const sizeY = (obj.geometry.parameters.height || 1) / 2;
        const sizeZ = (obj.geometry.parameters.depth || 1) / 2;
        if (distX < sizeX + 0.5 && distY < sizeY + 1.5 && distZ < sizeZ + 0.5){
          if (player.pos.z > obj.position.z) player.pos.z = obj.position.z + sizeZ + 0.5;
          else player.pos.z = obj.position.z - sizeZ - 0.5;
        }
      }

      // pick up gun
      if(!hasGun){
        const ray=new THREE.Raycaster();
        const dir=new THREE.Vector3(); camera.getWorldDirection(dir);
        ray.set(camera.position,dir);
        const hits=ray.intersectObject(gun,false);
        if(hits.length>0 && player.pos.distanceTo(gun.position)<3){
          document.getElementById('hint').textContent='Press E to grab gun';
          if(keys['KeyE']){ hasGun=true; scene.remove(gun); startCutscene(); }
        } else {
          if(!hasGun) document.getElementById('hint').textContent='WASD move · SPACE jump · Look at gun + E';
        }
      }

      // CUTSCENE camera rotation + spawn/windup/leap/land
      if(cutsceneActive){
        cutsceneTimer += dt;
        const angleDiff = shortestAngleDiff(yaw, cameraTurnTarget);
        const turnSpeed = 2.2;
        const maxTurn = turnSpeed * dt;
        if(Math.abs(angleDiff) > 0.01){
          yaw += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), maxTurn);
        } else {
          if(cutsceneStage === 0){
            const fwd = new THREE.Vector3();
            camera.getWorldDirection(fwd);
            const spawnPos = player.pos.clone().add(fwd.clone().multiplyScalar(22));
            monster.position.copy(spawnPos);
            monster.position.y = startPos.y + 9.0;
            monster.visible = true;
            monster.userData.state = 'windup';
            monster.userData.animTimer = 0;
            monster.userData.vy = 0;
            const horiz = new THREE.Vector3(player.pos.x - monster.position.x, 0, player.pos.z - monster.position.z);
            if(horiz.lengthSq() > 0.001) horiz.normalize();
            monster.userData.hVel = horiz.multiplyScalar(7.3);
            setLimbTargets({windUp:true});
            monsterSpeak('I will find you');
            cutsceneStage = 1;
          }
        }
      }

      // Monster animation update
      if(monster.visible && !gameOver){
        const state = monster.userData.state;
        if(state === 'windup'){
          monster.userData.animTimer += dt;
          const t = monster.userData.animTimer;
          monster.position.y = startPos.y + 9.0 + Math.sin(t * 6) * 0.25;
          monster.rotation.x = Math.sin(t * 3) * 0.08;
          // pulse head emissive a little to dramatize
          head.material.emissive = new THREE.Color(0xffc0d6);
          head.material.emissiveIntensity = 0.05 + Math.abs(Math.sin(t*8))*0.12;
          // limbs lerp
          lerpEuler(leftUpperArm.rotation, limbTargets.leftUpperArm, Math.min(1, dt*6));
          lerpEuler(leftLowerArm.rotation, limbTargets.leftLowerArm, Math.min(1, dt*6));
          lerpEuler(rightUpperArm.rotation, limbTargets.rightUpperArm, Math.min(1, dt*6));
          lerpEuler(rightLowerArm.rotation, limbTargets.rightLowerArm, Math.min(1, dt*6));
          lerpEuler(leftThigh.rotation, limbTargets.leftThigh, Math.min(1, dt*6));
          lerpEuler(leftShin.rotation, limbTargets.leftShin, Math.min(1, dt*6));
          lerpEuler(rightThigh.rotation, limbTargets.rightThigh, Math.min(1, dt*6));
          lerpEuler(rightShin.rotation, limbTargets.rightShin, Math.min(1, dt*6));
          if(monster.userData.animTimer > 1.0){
            monster.userData.state = 'leap';
            monster.userData.vy = -10.5;
            setLimbTargets({leap:true});
            cutsceneStage = 2;
          }
        } else if(state === 'leap'){
          monster.position.addScaledVector(monster.userData.hVel, dt);
          monster.userData.vy -= dt * 32;
          monster.position.y += monster.userData.vy * dt;
          monster.rotation.z = Math.max(-0.3, Math.min(0.3, monster.rotation.z + (monster.userData.vy * dt) * 0.02));
          lerpEuler(leftUpperArm.rotation, limbTargets.leftUpperArm, Math.min(1, dt*6));
          lerpEuler(leftLowerArm.rotation, limbTargets.leftLowerArm, Math.min(1, dt*6));
          lerpEuler(rightUpperArm.rotation, limbTargets.rightUpperArm, Math.min(1, dt*6));
          lerpEuler(rightLowerArm.rotation, limbTargets.rightLowerArm, Math.min(1, dt*6));
          lerpEuler(leftThigh.rotation, limbTargets.leftThigh, Math.min(1, dt*6));
          lerpEuler(leftShin.rotation, limbTargets.leftShin, Math.min(1, dt*6));
          lerpEuler(rightThigh.rotation, limbTargets.rightThigh, Math.min(1, dt*6));
          lerpEuler(rightShin.rotation, limbTargets.rightShin, Math.min(1, dt*6));
          if(monster.position.y <= startPos.y + 0.0){
            monster.position.y = startPos.y + 0.0;
            monster.userData.vy = 0;
            monster.userData.state = 'landed';
            monster.userData.landTimer = 0;
            setLimbTargets({land:true});
            spawnLandingParticles(new THREE.Vector3(monster.position.x, monster.position.y, monster.position.z));
            cameraShake.time = 0.25;
            cameraShake.duration = 0.25;
            cameraShake.intensity = 0.06;
            cutsceneStage = 3;
          }
        } else if(state === 'landed'){
          monster.userData.landTimer += dt;
          const lt = monster.userData.landTimer;
          const squash = 1 - 0.18 * Math.exp(-8 * lt);
          monster.scale.y = Math.max(0.82, squash);
          leftHand.position.set(-0.95 + Math.sin(leftUpperArm.rotation.z)*0.18, 1.15 + Math.sin(leftUpperArm.rotation.x)*-0.2, 0.25);
          leftFoot.position.y = -0.4 + Math.max(0, (1 - lt*4) * 0.02);
          rightFoot.position.y = -0.4;
          lerpEuler(leftUpperArm.rotation, limbTargets.leftUpperArm, Math.min(1, dt*8));
          lerpEuler(leftLowerArm.rotation, limbTargets.leftLowerArm, Math.min(1, dt*8));
          lerpEuler(rightUpperArm.rotation, limbTargets.rightUpperArm, Math.min(1, dt*8));
          lerpEuler(rightLowerArm.rotation, limbTargets.rightLowerArm, Math.min(1, dt*8));
          lerpEuler(leftThigh.rotation, limbTargets.leftThigh, Math.min(1, dt*8));
          lerpEuler(leftShin.rotation, limbTargets.leftShin, Math.min(1, dt*8));
          lerpEuler(rightThigh.rotation, limbTargets.rightThigh, Math.min(1, dt*8));
          lerpEuler(rightShin.rotation, limbTargets.rightShin, Math.min(1, dt*8));
          if(lt > 0.45){
            monster.scale.y = 1;
            cutsceneActive = false;
            chasing = true;
            cutsceneStage = 0;
            document.getElementById('status').textContent='RUN';
          }
        } else {
          monster.position.y = startPos.y + Math.sin(performance.now()*0.001) * 0.02;
        }
      }

      // update particles
      for(let i=particles.length-1;i>=0;--i){
        const p = particles[i];
        p.userData.vel.y -= 18 * dt;
        p.position.addScaledVector(p.userData.vel, dt);
        p.userData.life -= dt;
        const frac = Math.max(0, p.userData.life / 1.0);
        if(p.material) p.material.opacity = frac;
        if(p.userData.life <= 0){
          scene.remove(p);
          particles.splice(i,1);
        }
      }

      // chasing
      if(chasing && monster.visible && !gameOver){
        const dirToPlayer=new THREE.Vector3(player.pos.x-monster.position.x,0,player.pos.z-monster.position.z);
        const dist=dirToPlayer.length();
        if(dist>0.2){
          dirToPlayer.normalize();
          monster.position.addScaledVector(dirToPlayer,dt*4.2);
          const lookAtTarget = new THREE.Vector3(player.pos.x, monster.position.y, player.pos.z);
          monster.lookAt(lookAtTarget);
          monster.rotation.x = Math.sin(performance.now()*0.002 + monster.position.x) * 0.05;
        }
        document.getElementById('bossHP').style.width=Math.max(0,monsterHP)+'%';
        if(monster.position.distanceTo(player.pos)<1.2) lose();
      }

      // bullets
      for(let i=bullets.length-1;i>=0;--i){
        const b=bullets[i];
        b.mesh.position.addScaledVector(b.vel,dt);
        b.life-=dt;
        if(monster.visible && monsterHP>0){
          const d=b.mesh.position.distanceTo(monster.position);
          if(d<1){
            monsterHP-=20;
            scene.remove(b.mesh);
            bullets.splice(i,1);
            if(monsterHP<=0){
              monster.visible=false;
              win();
            }
            continue;
          }
        }
        if(b.life<=0){ scene.remove(b.mesh); bullets.splice(i,1); }
      }

      player.pos.x=Math.max(-2.5,Math.min(2.5,player.pos.x));
      if(chasing && Math.random()<0.02 && hall.children.length<300) spawnObstacle(player.pos.z-30);

      updateHall();

      // show/hide boss bar based on monster visibility and HP
      document.getElementById('bossBar').style.display = (monster.visible && !gameOver) ? 'block' : 'none';

      // smooth limb rotations to final visual
      lerpEuler(leftUpperArm.rotation, limbTargets.leftUpperArm, Math.min(1, dt*5));
      lerpEuler(leftLowerArm.rotation, limbTargets.leftLowerArm, Math.min(1, dt*5));
      lerpEuler(rightUpperArm.rotation, limbTargets.rightUpperArm, Math.min(1, dt*5));
      lerpEuler(rightLowerArm.rotation, limbTargets.rightLowerArm, Math.min(1, dt*5));
      lerpEuler(leftThigh.rotation, limbTargets.leftThigh, Math.min(1, dt*5));
      lerpEuler(leftShin.rotation, limbTargets.leftShin, Math.min(1, dt*5));
      lerpEuler(rightThigh.rotation, limbTargets.rightThigh, Math.min(1, dt*5));
      lerpEuler(rightShin.rotation, limbTargets.rightShin, Math.min(1, dt*5));

      renderer.render(scene,camera);
      if(!gameOver) requestAnimationFrame(loop);
    }

    // start at homepage render
    renderer.render(scene,camera);

    addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    function startGame(){ if(started) return; started=true; document.getElementById('status').textContent='Playing'; startYaw = yaw; startPos = player.pos.clone(); requestAnimationFrame(loop); }
    function spawnObstacle(z){ const o=new THREE.Mesh(new THREE.BoxGeometry(2,1,1), new THREE.MeshStandardMaterial({color:0x3a2416})); o.position.set(Math.random()>.5?1:-1,0.5,z); hall.add(o); }

    // small helper: occasionally clean up old objects
    setInterval(()=>{ /* noop for now */ }, 8000);

  </script>
</body>
</html>
